#include "K2Node_AddTrack.h"
#include "EdGraphSchema_K2.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "K2Node_CallFunction.h"
#include "KismetCompiler.h"

//本地化
#define LOCTEXT_NAMESPACE "K2Node_AddTrack"

UK2Node_AddTrack::UK2Node_AddTrack(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	NodeTooltip = LOCTEXT("NodeTooltip", "这是一个测试节点");
}

void UK2Node_AddTrack::AllocateDefaultPins()
{
	// //const UEnum* EnumPtr = FindObject<UEnum>(ANY_PACKAGE, TEXT("ETrackType"), true);
	// //const UEnumProperty* EnumProperty = EnumPtr;
	// const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();
	// //第二个参数PinCategory指定了引脚的匹配规则。UEdGraphSchema_K2::PC_Wildcard是由当前节点来定义匹配规则(就不是常见类型了)。匹配规则的意思是这个引脚可以传入什么样的数据或者说这个引脚是什么类型的

	// CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);//Pins[0]
	// CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Then);//Pins[1]
	// UEdGraphPin* inTypePin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Enum, "InType");//Pins[2]
	// CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Struct, "InTrack");//Pins[3]

	// //K2Schema->ConvertPropertyToPinType(EnumPtr, inTypePin->PinType);
	// //K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(inTypePin);

	// Super::AllocateDefaultPins();
}

FText UK2Node_AddTrack::GetNodeTitle(ENodeTitleType::Type Title) const
{
	return LOCTEXT("ListViewTitle", "Add Track");
}

FText UK2Node_AddTrack::GetTooltipText() const
{
	return NodeTooltip;
}

void UK2Node_AddTrack::ExpandNode(FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
	// Super::ExpandNode(CompilerContext, SourceGraph);

	// UEdGraphPin* ExecPin = GetExecPin();
	// UEdGraphPin* ThenPin = FindPinChecked(UEdGraphSchema_K2::PN_Then);
	// UEdGraphPin* InEnumPin = GetEnumPin();
	// UEdGraphPin* InStructPin = GetStructPin();


	// if (ExecPin && ThenPin) {

	// 	//绑定函数到节点上
	// 	FName AddTrackFunctionName = GET_FUNCTION_NAME_CHECKED(UAdvancedTimelineComponent, AddTrack);
	// 	UK2Node_CallFunction* CallFuncNode_AddTrack = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);
	// 	CallFuncNode_AddTrack->FunctionReference.SetExternalMember(AddTrackFunctionName, UAdvancedTimelineComponent::StaticClass());
	// 	CallFuncNode_AddTrack->AllocateDefaultPins();

	// 	// move pins
	// 	CompilerContext.MovePinLinksToIntermediate(*ExecPin, *(CallFuncNode_AddTrack->GetExecPin()));
	// 	CompilerContext.MovePinLinksToIntermediate(*ThenPin, *(CallFuncNode_AddTrack->GetThenPin()));
	// 	CompilerContext.MovePinLinksToIntermediate(*InEnumPin, *(CallFuncNode_AddTrack->FindPinChecked(FName("InType"))));
	// 	CompilerContext.MovePinLinksToIntermediate(*InStructPin, *(CallFuncNode_AddTrack->FindPinChecked(FName("InTrack"))));
	// }
	// BreakAllNodeLinks();
}

void UK2Node_AddTrack::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	// UClass* ActionKey = GetClass();

	// if (ActionRegistrar.IsOpenForRegistration(ActionKey))
	// {
	// 	UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
	// 	check(NodeSpawner != nullptr);

	// 	ActionRegistrar.AddBlueprintAction(ActionKey, NodeSpawner);
	// }
}

FText UK2Node_AddTrack::GetMenuCategory() const
{
	return FText::FromString(TEXT("AdvancedTimeline"));
}


#undef LOCTEXT_NAMESPACE
